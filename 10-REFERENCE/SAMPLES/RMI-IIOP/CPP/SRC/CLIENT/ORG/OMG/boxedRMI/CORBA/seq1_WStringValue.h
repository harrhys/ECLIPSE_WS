// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.1

#ifndef ___seq1_WStringValue_h__
#define ___seq1_WStringValue_h__

#include <OB/orb.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010100L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace org
{

namespace omg
{

namespace boxedRMI
{

namespace CORBA
{

class seq1_WStringValue;

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

void OBDuplicate(org::omg::boxedRMI::CORBA::seq1_WStringValue*);
void OBRelease(org::omg::boxedRMI::CORBA::seq1_WStringValue*);

void OBMarshal(org::omg::boxedRMI::CORBA::seq1_WStringValue*, OB::OutputStreamImpl*);
void OBUnmarshal(org::omg::boxedRMI::CORBA::seq1_WStringValue*&, OB::InputStreamImpl*);

namespace org
{

namespace omg
{

namespace boxedRMI
{

namespace CORBA
{

typedef OB::ObjVar< seq1_WStringValue > seq1_WStringValue_var;
typedef OB::ObjOut< seq1_WStringValue > seq1_WStringValue_out;

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

namespace OBStubImpl_org
{

namespace omg
{

namespace boxedRMI
{

namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

namespace OBStubImpl_org
{

namespace omg
{

namespace boxedRMI
{

namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

//
// IDL:org:1.0
//
namespace org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/CORBA:1.0
//
namespace CORBA
{

/**
 * @author Kumar Jayanti
 * @version 1.0
 * Since this class is in namesapce org/omg/boxedRMI/CORBA, there is
 * a BUG in Orbacus IDL compiler, it generates references to
 * ULong, ValueBase, Boolean etc as CORBA::ULong, CORBA::ValueBase,
 * CORBA::Boolean respectively.
 * FIX : Manually change the generated code to use ::CORBA::ULong,
 * ::CORBA::ValueBase, ::CORBA::Boolean etc.
 *
 */
//
// RMI:[Ljava.lang.String;:071DA8BE7F971128:A0F0A4387A3BB342
//
class seq1_WStringValue : virtual public ::CORBA::DefaultValueRefCountBase
{
    static const char* _ob_id_;
    class OBUnique { };
    typedef OB::ObjSeq< ::CORBA::WStringValue, OBUnique > _seq_type;
    typedef OB::SeqVar< OB::ObjSeq< ::CORBA::WStringValue, OBUnique > > _seq_var_type;
    typedef OB::SeqOut< OB::ObjSeq< ::CORBA::WStringValue, OBUnique > > _seq_out_type;
    _seq_var_type _ob_v_;

    seq1_WStringValue& operator=(const seq1_WStringValue&);

protected:

    virtual ~seq1_WStringValue() { }

public:

    seq1_WStringValue()
        : _ob_v_(new _seq_type) { }

    seq1_WStringValue(::CORBA::ULong max)
        : _ob_v_(new _seq_type(max)) { }

    seq1_WStringValue(::CORBA::ULong max, ::CORBA::ULong l, ::CORBA::WStringValue** v, ::CORBA::Boolean rel = false)
        : _ob_v_(new _seq_type(max, l, v, rel)) { }

    seq1_WStringValue(const seq1_WStringValue& _ob_a)
        : _ob_v_(new _seq_type(_ob_a._ob_v_.in())) { }

    seq1_WStringValue(const _seq_type& _ob_a)
        : _ob_v_(new _seq_type(_ob_a)) { }

    seq1_WStringValue& operator=(const _seq_type& _ob_a)
    {
        _ob_v_ = new _seq_type(_ob_a);
        return *this;
    }

    const _seq_type& _value() const
    {
        return _ob_v_.in();
    }

    _seq_type& _value()
    {
        return _ob_v_.inout();
    }

    void _value(const _seq_type& _ob_a)
    {
        _ob_v_ = new _seq_type(_ob_a);
    }

    const _seq_type& _boxed_in() const { return _ob_v_.in(); }
    _seq_type& _boxed_inout() { return _ob_v_.inout(); }
    _seq_type*& _boxed_out() { return _ob_v_.out(); }

    ::CORBA::ULong maximum() const { return _ob_v_.in().maximum(); }

    ::CORBA::ULong length() const { return _ob_v_.in().length(); }
    void length(::CORBA::ULong l) { _ob_v_ -> length(l); }

		/**
     * @author Kumar Jayanti
     * @version 1.0
     * BUG: Wrong signature generated by Orbacus IDL compiler, 
	   * FIX: Comment this and re-write as shown below
     */
    //OB::ObjForSeq<::CORBA::WStringValue*> operator[](::CORBA::ULong idx) { return _ob_v_[idx]; }
    ::CORBA::WStringValue* operator[](::CORBA::ULong idx) { return _ob_v_[idx]; }
    ::CORBA::WStringValue* operator[](::CORBA::ULong idx) const { return _ob_v_[idx]; }

    ::CORBA::Boolean release() const { return _ob_v_.in().release(); }

    void replace(::CORBA::ULong m, ::CORBA::ULong l, ::CORBA::WStringValue** d, ::CORBA::Boolean rel = false) { _ob_v_ -> replace(m, l, d, rel); }

    ::CORBA::WStringValue** get_buffer(::CORBA::Boolean orphan = false) { return _ob_v_ -> get_buffer(orphan); }
    ::CORBA::WStringValue* const * get_buffer() const { return _ob_v_.in().get_buffer(); }

    typedef seq1_WStringValue_var _var_type;

    virtual ::CORBA::ValueBase* _copy_value();
    static seq1_WStringValue* _downcast(::CORBA::ValueBase*);

    static const char* _OB_id();

    virtual const char* _OB_typeId() const;

    virtual void _OB_marshal(OB::OutputStreamImpl*);
    virtual void _OB_unmarshal(OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_seq1_WStringValue;

class seq1_WStringValue_init : public ::CORBA::ValueFactoryBase
{
    virtual ::CORBA::ValueBase* create_for_unmarshal();

public:
    seq1_WStringValue_init()
    {
    }

    virtual ~seq1_WStringValue_init()
    {
    }

    static seq1_WStringValue_init* _downcast(::CORBA::ValueFactory);
};

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

//
// IDL:org:1.0
//
namespace OBProxy_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/CORBA:1.0
//
namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBProxy_org

//
// IDL:org:1.0
//
namespace OBStubImpl_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/CORBA:1.0
//
namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

//
// IDL:org:1.0
//
namespace OBMarshalStubImpl_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/CORBA:1.0
//
namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBMarshalStubImpl_org

//
// IDL:org:1.0
//
namespace OBV_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/CORBA:1.0
//
namespace CORBA
{

} // End of namespace CORBA

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBV_org

//
// RMI:[Ljava.lang.String;:071DA8BE7F971128:A0F0A4387A3BB342
//
void operator<<=(CORBA::Any&, org::omg::boxedRMI::CORBA::seq1_WStringValue**);
void operator<<=(CORBA::Any&, org::omg::boxedRMI::CORBA::seq1_WStringValue*);
CORBA::Boolean operator>>=(const CORBA::Any&, org::omg::boxedRMI::CORBA::seq1_WStringValue*&);

inline void
operator<<=(CORBA::Any_var& any, org::omg::boxedRMI::CORBA::seq1_WStringValue** val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, org::omg::boxedRMI::CORBA::seq1_WStringValue* val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, org::omg::boxedRMI::CORBA::seq1_WStringValue*& val)
{
    return any.in() >>= val;
}

#endif
