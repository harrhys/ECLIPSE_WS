// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.1

#ifndef ___seq1_StackTraceElement_h__
#define ___seq1_StackTraceElement_h__

#include <java/lang/StackTraceElement.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010100L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace java
{

namespace lang
{

class StackTraceElement;

extern OB::TypeCodeConst _tc_StackTraceElement;

} // End of namespace lang

} // End of namespace java

namespace org
{

namespace omg
{

namespace boxedRMI
{

namespace java
{

namespace lang
{

class seq1_StackTraceElement;

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

void OBDuplicate(java::lang::StackTraceElement*);
void OBRelease(java::lang::StackTraceElement*);

void OBMarshal(java::lang::StackTraceElement*, OB::OutputStreamImpl*);
void OBUnmarshal(java::lang::StackTraceElement*&, OB::InputStreamImpl*);

void OBDuplicate(org::omg::boxedRMI::java::lang::seq1_StackTraceElement*);
void OBRelease(org::omg::boxedRMI::java::lang::seq1_StackTraceElement*);

void OBMarshal(org::omg::boxedRMI::java::lang::seq1_StackTraceElement*, OB::OutputStreamImpl*);
void OBUnmarshal(org::omg::boxedRMI::java::lang::seq1_StackTraceElement*&, OB::InputStreamImpl*);

namespace java
{

namespace lang
{

typedef OB::ObjVar< StackTraceElement > StackTraceElement_var;
typedef OB::ObjOut< StackTraceElement > StackTraceElement_out;

} // End of namespace lang

} // End of namespace java

namespace org
{

namespace omg
{

namespace boxedRMI
{

namespace java
{

namespace lang
{

typedef OB::ObjVar< seq1_StackTraceElement > seq1_StackTraceElement_var;
typedef OB::ObjOut< seq1_StackTraceElement > seq1_StackTraceElement_out;

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

namespace OBStubImpl_java
{

namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

namespace OBStubImpl_org
{

namespace omg
{

namespace boxedRMI
{

namespace java
{

namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

namespace OBStubImpl_java
{

namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

namespace OBStubImpl_org
{

namespace omg
{

namespace boxedRMI
{

namespace java
{

namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

//
// IDL:java:1.0
//
namespace java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace java

//
// IDL:org:1.0
//
namespace org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/java:1.0
//
namespace java
{

//
// IDL:org/omg/boxedRMI/java/lang:1.0
//
namespace lang
{

//
// RMI:[Ljava.lang.StackTraceElement;:CD38F9930EA8AAEC:6109C59A2636DD85
//
class seq1_StackTraceElement : virtual public CORBA::DefaultValueRefCountBase
{
    static const char* _ob_id_;
    class OBUnique { };
    typedef OB::ObjSeq< ::java::lang::StackTraceElement, OBUnique > _seq_type;
    typedef OB::SeqVar< OB::ObjSeq< ::java::lang::StackTraceElement, OBUnique > > _seq_var_type;
    typedef OB::SeqOut< OB::ObjSeq< ::java::lang::StackTraceElement, OBUnique > > _seq_out_type;
    _seq_var_type _ob_v_;

    seq1_StackTraceElement& operator=(const seq1_StackTraceElement&);

protected:

    virtual ~seq1_StackTraceElement() { }

public:

    seq1_StackTraceElement()
        : _ob_v_(new _seq_type) { }

    seq1_StackTraceElement(CORBA::ULong max)
        : _ob_v_(new _seq_type(max)) { }

    seq1_StackTraceElement(CORBA::ULong max, CORBA::ULong l, ::java::lang::StackTraceElement** v, CORBA::Boolean rel = false)
        : _ob_v_(new _seq_type(max, l, v, rel)) { }

    seq1_StackTraceElement(const seq1_StackTraceElement& _ob_a)
        : _ob_v_(new _seq_type(_ob_a._ob_v_.in())) { }

    seq1_StackTraceElement(const _seq_type& _ob_a)
        : _ob_v_(new _seq_type(_ob_a)) { }

    seq1_StackTraceElement& operator=(const _seq_type& _ob_a)
    {
        _ob_v_ = new _seq_type(_ob_a);
        return *this;
    }

    const _seq_type& _value() const
    {
        return _ob_v_.in();
    }

    _seq_type& _value()
    {
        return _ob_v_.inout();
    }

    void _value(const _seq_type& _ob_a)
    {
        _ob_v_ = new _seq_type(_ob_a);
    }

    const _seq_type& _boxed_in() const { return _ob_v_.in(); }
    _seq_type& _boxed_inout() { return _ob_v_.inout(); }
    _seq_type*& _boxed_out() { return _ob_v_.out(); }

    CORBA::ULong maximum() const { return _ob_v_.in().maximum(); }

    CORBA::ULong length() const { return _ob_v_.in().length(); }
    void length(CORBA::ULong l) { _ob_v_ -> length(l); }

    /**
     * BUG: Orbacus is generating the signature of the method wrongly
     * Comment and change the line below
     */
    //OB::ObjForSeq<::java::lang::StackTraceElement> operator[](CORBA::ULong idx) { return _ob_v_[idx]; }
    ::java::lang::StackTraceElement* operator[](CORBA::ULong idx) { return _ob_v_[idx]; }
    ::java::lang::StackTraceElement* operator[](CORBA::ULong idx) const { return _ob_v_[idx]; }

    CORBA::Boolean release() const { return _ob_v_.in().release(); }

    void replace(CORBA::ULong m, CORBA::ULong l, ::java::lang::StackTraceElement** d, CORBA::Boolean rel = false) { _ob_v_ -> replace(m, l, d, rel); }

    ::java::lang::StackTraceElement** get_buffer(CORBA::Boolean orphan = false) { return _ob_v_ -> get_buffer(orphan); }
    ::java::lang::StackTraceElement* const * get_buffer() const { return _ob_v_.in().get_buffer(); }

    typedef seq1_StackTraceElement_var _var_type;

    virtual CORBA::ValueBase* _copy_value();
    static seq1_StackTraceElement* _downcast(CORBA::ValueBase*);

    static const char* _OB_id();

    virtual const char* _OB_typeId() const;

    virtual void _OB_marshal(OB::OutputStreamImpl*);
    virtual void _OB_unmarshal(OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_seq1_StackTraceElement;

class seq1_StackTraceElement_init : public CORBA::ValueFactoryBase
{
    virtual CORBA::ValueBase* create_for_unmarshal();

public:
    seq1_StackTraceElement_init()
    {
    }

    virtual ~seq1_StackTraceElement_init()
    {
    }

    static seq1_StackTraceElement_init* _downcast(CORBA::ValueFactory);
};

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace org

//
// IDL:java:1.0
//
namespace OBProxy_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBProxy_java

//
// IDL:org:1.0
//
namespace OBProxy_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/java:1.0
//
namespace java
{

//
// IDL:org/omg/boxedRMI/java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBProxy_org

//
// IDL:java:1.0
//
namespace OBStubImpl_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

//
// IDL:org:1.0
//
namespace OBStubImpl_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/java:1.0
//
namespace java
{

//
// IDL:org/omg/boxedRMI/java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBStubImpl_org

//
// IDL:java:1.0
//
namespace OBMarshalStubImpl_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBMarshalStubImpl_java

//
// IDL:org:1.0
//
namespace OBMarshalStubImpl_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/java:1.0
//
namespace java
{

//
// IDL:org/omg/boxedRMI/java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBMarshalStubImpl_org

//
// IDL:java:1.0
//
namespace OBV_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBV_java

//
// IDL:org:1.0
//
namespace OBV_org
{

//
// IDL:org/omg:1.0
//
namespace omg
{

//
// IDL:org/omg/boxedRMI:1.0
//
namespace boxedRMI
{

//
// IDL:org/omg/boxedRMI/java:1.0
//
namespace java
{

//
// IDL:org/omg/boxedRMI/java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace java

} // End of namespace boxedRMI

} // End of namespace omg

} // End of namespace OBV_org

//
// RMI:[Ljava.lang.StackTraceElement;:CD38F9930EA8AAEC:6109C59A2636DD85
//
void operator<<=(CORBA::Any&, org::omg::boxedRMI::java::lang::seq1_StackTraceElement**);
void operator<<=(CORBA::Any&, org::omg::boxedRMI::java::lang::seq1_StackTraceElement*);
CORBA::Boolean operator>>=(const CORBA::Any&, org::omg::boxedRMI::java::lang::seq1_StackTraceElement*&);

inline void
operator<<=(CORBA::Any_var& any, org::omg::boxedRMI::java::lang::seq1_StackTraceElement** val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, org::omg::boxedRMI::java::lang::seq1_StackTraceElement* val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, org::omg::boxedRMI::java::lang::seq1_StackTraceElement*& val)
{
    return any.in() >>= val;
}

#endif
