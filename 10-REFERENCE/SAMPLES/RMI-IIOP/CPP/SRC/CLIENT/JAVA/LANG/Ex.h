// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.1

#ifndef ___Ex_h__
#define ___Ex_h__

#include <java/lang/Exception.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010100L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace java
{

namespace lang
{

class Exception;

extern OB::TypeCodeConst _tc_Exception;

} // End of namespace lang

} // End of namespace java

void OBDuplicate(java::lang::Exception*);
void OBRelease(java::lang::Exception*);

void OBMarshal(java::lang::Exception*, OB::OutputStreamImpl*);
void OBUnmarshal(java::lang::Exception*&, OB::InputStreamImpl*);

namespace java
{

namespace lang
{

typedef OB::ObjVar< Exception > Exception_var;
typedef OB::ObjOut< Exception > Exception_out;

} // End of namespace lang

} // End of namespace java

namespace OBStubImpl_java
{

namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

namespace OBStubImpl_java
{

namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

//
// IDL:java:1.0
//
namespace java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

//
// IDL:java/lang/Ex:1.0
//
struct Ex : public CORBA::UserException
{
    Ex() { }
    Ex(const Ex&);
    Ex& operator=(const Ex&);

    static Ex* _downcast(CORBA::Exception*);
    static const Ex* _downcast(const CORBA::Exception*);
    virtual const char* _name() const;
    virtual void _raise() const { throw *this; }
    virtual const char* _rep_id() const;
    virtual char* _to_string() const;

    virtual CORBA::Exception* _OB_clone() const;
    virtual void _OB_insertInAny(CORBA::Any&);

    Exception_var value;

/**
 *BUG: The Orbacus compiler generates Exception* as parameter, which
 *gets resolved to CORBA::Exception*, whereas what we need here is
 *java::lang::Exception*
 */

    Ex(java::lang::Exception*);

    virtual void _OB_marshal(OB::OutputStreamImpl*) const;
    static void _OB_unmarshal(Ex&, OB::InputStreamImpl*);
};

extern OB::TypeCodeConst _tc_Ex;

} // End of namespace lang

} // End of namespace java

//
// IDL:java:1.0
//
namespace OBProxy_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBProxy_java

//
// IDL:java:1.0
//
namespace OBStubImpl_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBStubImpl_java

//
// IDL:java:1.0
//
namespace OBMarshalStubImpl_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBMarshalStubImpl_java

//
// IDL:java:1.0
//
namespace OBV_java
{

//
// IDL:java/lang:1.0
//
namespace lang
{

} // End of namespace lang

} // End of namespace OBV_java

//
// IDL:java/lang/Ex:1.0
//
void operator<<=(CORBA::Any&, java::lang::Ex*);
void operator<<=(CORBA::Any&, const java::lang::Ex&);
CORBA::Boolean operator>>=(const CORBA::Any&, const java::lang::Ex*&);

inline void
operator<<=(CORBA::Any_var& any, java::lang::Ex* val)
{
    any.inout() <<= val;
}

inline void
operator<<=(CORBA::Any_var& any, const java::lang::Ex& val)
{
    any.inout() <<= val;
}

inline CORBA::Boolean
operator>>=(const CORBA::Any_var& any, const java::lang::Ex*& val)
{
    return any.in() >>= val;
}

#endif
