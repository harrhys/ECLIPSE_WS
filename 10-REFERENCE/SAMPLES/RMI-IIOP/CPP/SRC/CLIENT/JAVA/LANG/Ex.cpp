// **********************************************************************
//
// Generated by the ORBacus IDL-to-C++ Translator
//
// Copyright (c) 2001
// IONA Technologies, Inc.
// Waltham, MA, USA
//
// All Rights Reserved
//
// **********************************************************************

// Version: 4.1.1

#include <OB/CORBAClient.h>
#include <Ex.h>

#ifndef OB_INTEGER_VERSION
#   error No ORBacus version defined! Is <OB/CORBA.h> included?
#endif

#ifndef OB_NO_VERSION_CHECK
#   if (OB_INTEGER_VERSION != 4010100L)
#       error ORBacus version mismatch!
#   endif
#endif

namespace java
{

namespace lang
{

::OB::TypeCodeConst _tc_Ex(
"0000000100000016000000fc0086a6b00000001549444c3a6a6176612f6c616e672f45783a312"
"e30000000000000000345780000000000010000000676616c75650000000000001d000000bc00"
"1b91300000003a524d493a6a6176612e6c616e672e457863657074696f6e3a373745384236324"
"344374537394141323a443046443146334531413342314343340000010000000a457863657074"
"696f6e0000000000001d0000005c004400000000003a524d493a6a6176612e6c616e672e54687"
"26f7761626c653a463836373842344634443245423730353a4435433633353237333937374238"
"43420000140000000a5468726f7761626c65000000000000000000000000000000"
);

} // End of namespace lang

} // End of namespace java

//
// IDL:java/lang/Ex:1.0
//
java::lang::Ex::Ex(const Ex& _ob_a)
    : CORBA::UserException(_ob_a),
      value(_ob_a.value)
{
}

/**
 *BUG: The Orbacus compiler generates Exception* as parameter, which
 *gets resolved to CORBA::Exception*, whereas what we need here is
 *java::lang::Exception*
 */
java::lang::Ex::Ex(java::lang::Exception* _ob_a0)
    : value(_ob_a0)
{
}

java::lang::Ex&
java::lang::Ex::operator=(const Ex& _ob_a)
{
    if(this != &_ob_a)
    {
        value = _ob_a.value;
    }
    return *this;
}

java::lang::Ex*
java::lang::Ex::_downcast(CORBA::Exception* p)
{
    return dynamic_cast<Ex*>(p);
}

const java::lang::Ex*
java::lang::Ex::_downcast(const CORBA::Exception* p)
{
    return dynamic_cast<const Ex*>(p);
}

const char*
java::lang::Ex::_name() const
{
    return "Ex";
}

const char*
java::lang::Ex::_rep_id() const
{
    return "IDL:java/lang/Ex:1.0";
}

char*
java::lang::Ex::_to_string() const
{
    return _OB_defaultToString("java::lang::Ex");
}

CORBA::Exception*
java::lang::Ex::_OB_clone() const
{
    return new Ex(*this);
}

void
java::lang::Ex::_OB_insertInAny(CORBA::Any& any)
{
    any <<= this;
}

void
java::lang::Ex::_OB_marshal(OB::OutputStreamImpl* _ob_out) const
{
#ifdef HAVE_VCPLUSPLUS_BUGS
    UserException::_OB_marshal(_ob_out);
#else
    CORBA::UserException::_OB_marshal(_ob_out);
#endif
    OBMarshal(value, _ob_out);
}

void
java::lang::Ex::_OB_unmarshal(Ex& _ob_v, OB::InputStreamImpl* _ob_in)
{
    CORBA::String_var id = _ob_in -> read_string();
    assert(strcmp(id, "IDL:java/lang/Ex:1.0") == 0);
    OBUnmarshal(_ob_v.value.out(), _ob_in);
}

void
operator<<=(CORBA::Any& any, java::lang::Ex* v)
{
    static const OB::Info< java::lang::Ex > info;
    any.replace(java::lang::_tc_Ex, v, true, &info);
}

void
operator<<=(CORBA::Any& any, const java::lang::Ex& v)
{
    any <<= new java::lang::Ex(v);
}

CORBA::Boolean
operator>>=(const CORBA::Any& any, const java::lang::Ex*& v)
{
    if(any.check_type(java::lang::_tc_Ex))
    {
        if(!any.info())
        {
            OB::InputStream_var _ob_in = any.create_input_stream();
            java::lang::Ex* val = new java::lang::Ex;
            java::lang::Ex::_OB_unmarshal(*val, _ob_in);
            (CORBA::Any&)any <<= val;
        }

        v = (java::lang::Ex*)any.value();
        return true;
    }
    else
        return false;
}
